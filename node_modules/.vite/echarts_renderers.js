import {
  BoundingRect_default,
  DEFAULT_FONT,
  Eventful_default,
  Image_default,
  Path_default,
  REDARAW_BIT,
  TSpan_default,
  WeakMap_default,
  __extends,
  brush,
  brushSingle,
  createCanvas,
  createCanvasPattern,
  createOrUpdateImage,
  devicePixelRatio,
  each,
  env_default,
  extend,
  getCanvasGradient,
  getLineHeight,
  indexOf,
  isClipPathChanged,
  isGradientObject,
  isImagePatternObject,
  isObject,
  logError,
  map,
  merge,
  normalizeLineDash,
  parse,
  requestAnimationFrame_default,
  toHex
} from "./chunk-QOD5633Y.js";
import "./chunk-A5ICIBVI.js";

// node_modules/zrender/lib/svg/core.js
function createElement(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}

// node_modules/zrender/lib/core/arrayDiff.js
function diff(oldArr, newArr, equals) {
  if (!equals) {
    equals = function(a, b) {
      return a === b;
    };
  }
  oldArr = oldArr.slice();
  newArr = newArr.slice();
  var newLen = newArr.length;
  var oldLen = oldArr.length;
  var editLength = 1;
  var maxEditLength = newLen + oldLen;
  var bestPath = [{ newPos: -1, components: [] }];
  var oldPos = extractCommon(bestPath[0], newArr, oldArr, 0, equals);
  if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
    var indices = [];
    for (var i = 0; i < newArr.length; i++) {
      indices.push(i);
    }
    return [{
      indices,
      count: newArr.length,
      added: false,
      removed: false
    }];
  }
  function execEditLength() {
    for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
      var basePath;
      var addPath = bestPath[diagonalPath - 1];
      var removePath = bestPath[diagonalPath + 1];
      var oldPos2 = (removePath ? removePath.newPos : 0) - diagonalPath;
      if (addPath) {
        bestPath[diagonalPath - 1] = void 0;
      }
      var canAdd = addPath && addPath.newPos + 1 < newLen;
      var canRemove = removePath && 0 <= oldPos2 && oldPos2 < oldLen;
      if (!canAdd && !canRemove) {
        bestPath[diagonalPath] = void 0;
        continue;
      }
      if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
        basePath = clonePath(removePath);
        pushComponent(basePath.components, false, true);
      } else {
        basePath = addPath;
        basePath.newPos++;
        pushComponent(basePath.components, true, false);
      }
      oldPos2 = extractCommon(basePath, newArr, oldArr, diagonalPath, equals);
      if (basePath.newPos + 1 >= newLen && oldPos2 + 1 >= oldLen) {
        return buildValues(basePath.components);
      } else {
        bestPath[diagonalPath] = basePath;
      }
    }
    editLength++;
  }
  while (editLength <= maxEditLength) {
    var ret = execEditLength();
    if (ret) {
      return ret;
    }
  }
}
function extractCommon(basePath, newArr, oldArr, diagonalPath, equals) {
  var newLen = newArr.length;
  var oldLen = oldArr.length;
  var newPos = basePath.newPos;
  var oldPos = newPos - diagonalPath;
  var commonCount = 0;
  while (newPos + 1 < newLen && oldPos + 1 < oldLen && equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
    newPos++;
    oldPos++;
    commonCount++;
  }
  if (commonCount) {
    basePath.components.push({
      count: commonCount,
      added: false,
      removed: false,
      indices: []
    });
  }
  basePath.newPos = newPos;
  return oldPos;
}
function pushComponent(components, added, removed) {
  var last = components[components.length - 1];
  if (last && last.added === added && last.removed === removed) {
    components[components.length - 1] = {
      count: last.count + 1,
      added,
      removed,
      indices: []
    };
  } else {
    components.push({
      count: 1,
      added,
      removed,
      indices: []
    });
  }
}
function buildValues(components) {
  var componentPos = 0;
  var componentLen = components.length;
  var newPos = 0;
  var oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      var indices = [];
      for (var i = newPos; i < newPos + component.count; i++) {
        indices.push(i);
      }
      component.indices = indices;
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      for (var i = oldPos; i < oldPos + component.count; i++) {
        component.indices.push(i);
      }
      oldPos += component.count;
    }
  }
  return components;
}
function clonePath(path) {
  return { newPos: path.newPos, components: path.components.slice(0) };
}
function arrayDiff(oldArr, newArr, equal) {
  return diff(oldArr, newArr, equal);
}

// node_modules/zrender/lib/svg/graphic.js
var NONE = "none";
var mathRound = Math.round;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;
var PI2 = Math.PI * 2;
var degree = 180 / PI;
var EPSILON = 1e-4;
function round3(val) {
  return mathRound(val * 1e3) / 1e3;
}
function round4(val) {
  return mathRound(val * 1e4) / 1e4;
}
function isAroundZero(val) {
  return val < EPSILON && val > -EPSILON;
}
function pathHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  var stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
function setTransform(svgEl, m) {
  if (m) {
    attr(svgEl, "transform", "matrix(" + round3(m[0]) + "," + round3(m[1]) + "," + round3(m[2]) + "," + round3(m[3]) + "," + round4(m[4]) + "," + round4(m[5]) + ")");
  }
}
function attr(el, key, val) {
  if (!val || val.type !== "linear" && val.type !== "radial") {
    el.setAttribute(key, val);
  }
}
function attrXLink(el, key, val) {
  el.setAttributeNS("http://www.w3.org/1999/xlink", key, val);
}
function attrXML(el, key, val) {
  el.setAttributeNS("http://www.w3.org/XML/1998/namespace", key, val);
}
function bindStyle(svgEl, style, el) {
  var opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof Image_default) {
    svgEl.style.opacity = opacity + "";
    return;
  }
  if (pathHasFill(style)) {
    var fill = style.fill;
    fill = fill === "transparent" ? NONE : fill;
    attr(svgEl, "fill", fill);
    attr(svgEl, "fill-opacity", (style.fillOpacity != null ? style.fillOpacity * opacity : opacity) + "");
  } else {
    attr(svgEl, "fill", NONE);
  }
  if (pathHasStroke(style)) {
    var stroke = style.stroke;
    stroke = stroke === "transparent" ? NONE : stroke;
    attr(svgEl, "stroke", stroke);
    var strokeWidth = style.lineWidth;
    var strokeScale_1 = style.strokeNoScale ? el.getLineScale() : 1;
    attr(svgEl, "stroke-width", (strokeScale_1 ? strokeWidth / strokeScale_1 : 0) + "");
    attr(svgEl, "paint-order", style.strokeFirst ? "stroke" : "fill");
    attr(svgEl, "stroke-opacity", (style.strokeOpacity != null ? style.strokeOpacity * opacity : opacity) + "");
    var lineDash = style.lineDash && strokeWidth > 0 && normalizeLineDash(style.lineDash, strokeWidth);
    if (lineDash) {
      var lineDashOffset = style.lineDashOffset;
      if (strokeScale_1 && strokeScale_1 !== 1) {
        lineDash = map(lineDash, function(rawVal) {
          return rawVal / strokeScale_1;
        });
        if (lineDashOffset) {
          lineDashOffset /= strokeScale_1;
          lineDashOffset = mathRound(lineDashOffset);
        }
      }
      attr(svgEl, "stroke-dasharray", lineDash.join(","));
      attr(svgEl, "stroke-dashoffset", (lineDashOffset || 0) + "");
    } else {
      attr(svgEl, "stroke-dasharray", "");
    }
    style.lineCap && attr(svgEl, "stroke-linecap", style.lineCap);
    style.lineJoin && attr(svgEl, "stroke-linejoin", style.lineJoin);
    style.miterLimit && attr(svgEl, "stroke-miterlimit", style.miterLimit + "");
  } else {
    attr(svgEl, "stroke", NONE);
  }
}
var SVGPathRebuilder = function() {
  function SVGPathRebuilder2() {
  }
  SVGPathRebuilder2.prototype.reset = function() {
    this._d = [];
    this._str = "";
  };
  SVGPathRebuilder2.prototype.moveTo = function(x, y) {
    this._add("M", x, y);
  };
  SVGPathRebuilder2.prototype.lineTo = function(x, y) {
    this._add("L", x, y);
  };
  SVGPathRebuilder2.prototype.bezierCurveTo = function(x, y, x2, y2, x3, y3) {
    this._add("C", x, y, x2, y2, x3, y3);
  };
  SVGPathRebuilder2.prototype.quadraticCurveTo = function(x, y, x2, y2) {
    this._add("Q", x, y, x2, y2);
  };
  SVGPathRebuilder2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  };
  SVGPathRebuilder2.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    var firstCmd = this._d.length === 0;
    var dTheta = endAngle - startAngle;
    var clockwise = !anticlockwise;
    var dThetaPositive = Math.abs(dTheta);
    var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);
    var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
    var large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI === !!clockwise;
    }
    var x0 = round4(cx + rx * mathCos(startAngle));
    var y0 = round4(cy + ry * mathSin(startAngle));
    if (isCircle) {
      if (clockwise) {
        dTheta = PI2 - 1e-4;
      } else {
        dTheta = -PI2 + 1e-4;
      }
      large = true;
      if (firstCmd) {
        this._d.push("M", x0, y0);
      }
    }
    var x = round4(cx + rx * mathCos(startAngle + dTheta));
    var y = round4(cy + ry * mathSin(startAngle + dTheta));
    if (isNaN(x0) || isNaN(y0) || isNaN(rx) || isNaN(ry) || isNaN(psi) || isNaN(degree) || isNaN(x) || isNaN(y)) {
      return "";
    }
    this._d.push("A", round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
  };
  SVGPathRebuilder2.prototype.rect = function(x, y, w, h) {
    this._add("M", x, y);
    this._add("L", x + w, y);
    this._add("L", x + w, y + h);
    this._add("L", x, y + h);
    this._add("L", x, y);
  };
  SVGPathRebuilder2.prototype.closePath = function() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  };
  SVGPathRebuilder2.prototype._add = function(cmd, a, b, c, d, e, f, g, h) {
    this._d.push(cmd);
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      this._d.push(round4(val));
    }
  };
  SVGPathRebuilder2.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(" ");
    this._d = [];
  };
  SVGPathRebuilder2.prototype.getStr = function() {
    return this._str;
  };
  return SVGPathRebuilder2;
}();
var svgPath = {
  brush: function(el) {
    var style = el.style;
    var svgEl = el.__svgEl;
    if (!svgEl) {
      svgEl = createElement("path");
      el.__svgEl = svgEl;
    }
    if (!el.path) {
      el.createPathProxy();
    }
    var path = el.path;
    if (el.shapeChanged()) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    var pathVersion = path.getVersion();
    var elExt = el;
    var svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || el.style.strokePercent < 1) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder();
      }
      svgPathBuilder.reset();
      path.rebuildPath(svgPathBuilder, el.style.strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
    }
    attr(svgEl, "d", svgPathBuilder.getStr());
    bindStyle(svgEl, style, el);
    setTransform(svgEl, el.transform);
  }
};
var svgImage = {
  brush: function(el) {
    var style = el.style;
    var image = style.image;
    if (image instanceof HTMLImageElement) {
      image = image.src;
    } else if (image instanceof HTMLCanvasElement) {
      image = image.toDataURL();
    }
    if (!image) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var dw = style.width;
    var dh = style.height;
    var svgEl = el.__svgEl;
    if (!svgEl) {
      svgEl = createElement("image");
      el.__svgEl = svgEl;
    }
    if (image !== el.__imageSrc) {
      attrXLink(svgEl, "href", image);
      el.__imageSrc = image;
    }
    attr(svgEl, "width", dw + "");
    attr(svgEl, "height", dh + "");
    attr(svgEl, "x", x + "");
    attr(svgEl, "y", y + "");
    bindStyle(svgEl, style, el);
    setTransform(svgEl, el.transform);
  }
};
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY(y, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y -= lineHeight / 2;
  }
  return y;
}
var svgText = {
  brush: function(el) {
    var style = el.style;
    var text = style.text;
    text != null && (text += "");
    if (!text || isNaN(style.x) || isNaN(style.y)) {
      return;
    }
    var textSvgEl = el.__svgEl;
    if (!textSvgEl) {
      textSvgEl = createElement("text");
      attrXML(textSvgEl, "xml:space", "preserve");
      el.__svgEl = textSvgEl;
    }
    var font = style.font || DEFAULT_FONT;
    var textSvgElStyle = textSvgEl.style;
    textSvgElStyle.font = font;
    textSvgEl.textContent = text;
    bindStyle(textSvgEl, style, el);
    setTransform(textSvgEl, el.transform);
    var x = style.x || 0;
    var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);
    var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
    attr(textSvgEl, "dominant-baseline", "central");
    attr(textSvgEl, "text-anchor", textAlign);
    attr(textSvgEl, "x", x + "");
    attr(textSvgEl, "y", y + "");
  }
};

// node_modules/zrender/lib/svg/helper/Definable.js
var MARK_UNUSED = "0";
var MARK_USED = "1";
var Definable = function() {
  function Definable2(zrId, svgRoot, tagNames, markLabel, domName) {
    this.nextId = 0;
    this._domName = "_dom";
    this.createElement = createElement;
    this._zrId = zrId;
    this._svgRoot = svgRoot;
    this._tagNames = typeof tagNames === "string" ? [tagNames] : tagNames;
    this._markLabel = markLabel;
    if (domName) {
      this._domName = domName;
    }
  }
  Definable2.prototype.getDefs = function(isForceCreating) {
    var svgRoot = this._svgRoot;
    var defs = this._svgRoot.getElementsByTagName("defs");
    if (defs.length === 0) {
      if (isForceCreating) {
        var defs_1 = svgRoot.insertBefore(this.createElement("defs"), svgRoot.firstChild);
        if (!defs_1.contains) {
          defs_1.contains = function(el) {
            var children = defs_1.children;
            if (!children) {
              return false;
            }
            for (var i = children.length - 1; i >= 0; --i) {
              if (children[i] === el) {
                return true;
              }
            }
            return false;
          };
        }
        return defs_1;
      } else {
        return null;
      }
    } else {
      return defs[0];
    }
  };
  Definable2.prototype.doUpdate = function(target, onUpdate) {
    if (!target) {
      return;
    }
    var defs = this.getDefs(false);
    if (target[this._domName] && defs.contains(target[this._domName])) {
      if (typeof onUpdate === "function") {
        onUpdate(target);
      }
    } else {
      var dom = this.add(target);
      if (dom) {
        target[this._domName] = dom;
      }
    }
  };
  Definable2.prototype.add = function(target) {
    return null;
  };
  Definable2.prototype.addDom = function(dom) {
    var defs = this.getDefs(true);
    if (dom.parentNode !== defs) {
      defs.appendChild(dom);
    }
  };
  Definable2.prototype.removeDom = function(target) {
    var defs = this.getDefs(false);
    if (defs && target[this._domName]) {
      defs.removeChild(target[this._domName]);
      target[this._domName] = null;
    }
  };
  Definable2.prototype.getDoms = function() {
    var defs = this.getDefs(false);
    if (!defs) {
      return [];
    }
    var doms = [];
    each(this._tagNames, function(tagName) {
      var tags = defs.getElementsByTagName(tagName);
      for (var i = 0; i < tags.length; i++) {
        doms.push(tags[i]);
      }
    });
    return doms;
  };
  Definable2.prototype.markAllUnused = function() {
    var doms = this.getDoms();
    var that = this;
    each(doms, function(dom) {
      dom[that._markLabel] = MARK_UNUSED;
    });
  };
  Definable2.prototype.markDomUsed = function(dom) {
    dom && (dom[this._markLabel] = MARK_USED);
  };
  ;
  Definable2.prototype.markDomUnused = function(dom) {
    dom && (dom[this._markLabel] = MARK_UNUSED);
  };
  ;
  Definable2.prototype.isDomUnused = function(dom) {
    return dom && dom[this._markLabel] !== MARK_USED;
  };
  Definable2.prototype.removeUnused = function() {
    var _this = this;
    var defs = this.getDefs(false);
    if (!defs) {
      return;
    }
    var doms = this.getDoms();
    each(doms, function(dom) {
      if (_this.isDomUnused(dom)) {
        defs.removeChild(dom);
      }
    });
  };
  Definable2.prototype.getSvgProxy = function(displayable) {
    if (displayable instanceof Path_default) {
      return svgPath;
    } else if (displayable instanceof Image_default) {
      return svgImage;
    } else if (displayable instanceof TSpan_default) {
      return svgText;
    } else {
      return svgPath;
    }
  };
  Definable2.prototype.getSvgElement = function(displayable) {
    return displayable.__svgEl;
  };
  return Definable2;
}();
var Definable_default = Definable;

// node_modules/zrender/lib/svg/helper/GradientManager.js
function isLinearGradient(value) {
  return value.type === "linear";
}
function isRadialGradient(value) {
  return value.type === "radial";
}
function isGradient(value) {
  return value && (value.type === "linear" || value.type === "radial");
}
var GradientManager = function(_super) {
  __extends(GradientManager2, _super);
  function GradientManager2(zrId, svgRoot) {
    return _super.call(this, zrId, svgRoot, ["linearGradient", "radialGradient"], "__gradient_in_use__") || this;
  }
  GradientManager2.prototype.addWithoutUpdate = function(svgElement, displayable) {
    if (displayable && displayable.style) {
      var that_1 = this;
      each(["fill", "stroke"], function(fillOrStroke) {
        var value = displayable.style[fillOrStroke];
        if (isGradient(value)) {
          var gradient = value;
          var defs = that_1.getDefs(true);
          var dom = void 0;
          if (gradient.__dom) {
            dom = gradient.__dom;
            if (!defs.contains(gradient.__dom)) {
              that_1.addDom(dom);
            }
          } else {
            dom = that_1.add(gradient);
          }
          that_1.markUsed(displayable);
          var id = dom.getAttribute("id");
          svgElement.setAttribute(fillOrStroke, "url(#" + id + ")");
        }
      });
    }
  };
  GradientManager2.prototype.add = function(gradient) {
    var dom;
    if (isLinearGradient(gradient)) {
      dom = this.createElement("linearGradient");
    } else if (isRadialGradient(gradient)) {
      dom = this.createElement("radialGradient");
    } else {
      logError("Illegal gradient type.");
      return null;
    }
    gradient.id = gradient.id || this.nextId++;
    dom.setAttribute("id", "zr" + this._zrId + "-gradient-" + gradient.id);
    this.updateDom(gradient, dom);
    this.addDom(dom);
    return dom;
  };
  GradientManager2.prototype.update = function(gradient) {
    if (!isGradient(gradient)) {
      return;
    }
    var that = this;
    this.doUpdate(gradient, function() {
      var dom = gradient.__dom;
      if (!dom) {
        return;
      }
      var tagName = dom.tagName;
      var type = gradient.type;
      if (type === "linear" && tagName === "linearGradient" || type === "radial" && tagName === "radialGradient") {
        that.updateDom(gradient, gradient.__dom);
      } else {
        that.removeDom(gradient);
        that.add(gradient);
      }
    });
  };
  GradientManager2.prototype.updateDom = function(gradient, dom) {
    if (isLinearGradient(gradient)) {
      dom.setAttribute("x1", gradient.x + "");
      dom.setAttribute("y1", gradient.y + "");
      dom.setAttribute("x2", gradient.x2 + "");
      dom.setAttribute("y2", gradient.y2 + "");
    } else if (isRadialGradient(gradient)) {
      dom.setAttribute("cx", gradient.x + "");
      dom.setAttribute("cy", gradient.y + "");
      dom.setAttribute("r", gradient.r + "");
    } else {
      logError("Illegal gradient type.");
      return;
    }
    if (gradient.global) {
      dom.setAttribute("gradientUnits", "userSpaceOnUse");
    } else {
      dom.setAttribute("gradientUnits", "objectBoundingBox");
    }
    dom.innerHTML = "";
    var colors = gradient.colorStops;
    for (var i = 0, len = colors.length; i < len; ++i) {
      var stop_1 = this.createElement("stop");
      stop_1.setAttribute("offset", colors[i].offset * 100 + "%");
      var color = colors[i].color;
      if (color.indexOf("rgba") > -1) {
        var opacity = parse(color)[3];
        var hex = toHex(color);
        stop_1.setAttribute("stop-color", "#" + hex);
        stop_1.setAttribute("stop-opacity", opacity + "");
      } else {
        stop_1.setAttribute("stop-color", colors[i].color);
      }
      dom.appendChild(stop_1);
    }
    gradient.__dom = dom;
  };
  GradientManager2.prototype.markUsed = function(displayable) {
    if (displayable.style) {
      var gradient = displayable.style.fill;
      if (gradient && gradient.__dom) {
        _super.prototype.markDomUsed.call(this, gradient.__dom);
      }
      gradient = displayable.style.stroke;
      if (gradient && gradient.__dom) {
        _super.prototype.markDomUsed.call(this, gradient.__dom);
      }
    }
  };
  return GradientManager2;
}(Definable_default);
var GradientManager_default = GradientManager;

// node_modules/zrender/lib/svg/helper/PatternManager.js
function isPattern(value) {
  return value && (!!value.image || !!value.svgElement);
}
var patternDomMap = new WeakMap_default();
var PatternManager = function(_super) {
  __extends(PatternManager2, _super);
  function PatternManager2(zrId, svgRoot) {
    return _super.call(this, zrId, svgRoot, ["pattern"], "__pattern_in_use__") || this;
  }
  PatternManager2.prototype.addWithoutUpdate = function(svgElement, displayable) {
    if (displayable && displayable.style) {
      var that_1 = this;
      each(["fill", "stroke"], function(fillOrStroke) {
        var pattern = displayable.style[fillOrStroke];
        if (isPattern(pattern)) {
          var defs = that_1.getDefs(true);
          var dom = patternDomMap.get(pattern);
          if (dom) {
            if (!defs.contains(dom)) {
              that_1.addDom(dom);
            }
          } else {
            dom = that_1.add(pattern);
          }
          that_1.markUsed(displayable);
          var id = dom.getAttribute("id");
          svgElement.setAttribute(fillOrStroke, "url(#" + id + ")");
        }
      });
    }
  };
  PatternManager2.prototype.add = function(pattern) {
    if (!isPattern(pattern)) {
      return;
    }
    var dom = this.createElement("pattern");
    pattern.id = pattern.id == null ? this.nextId++ : pattern.id;
    dom.setAttribute("id", "zr" + this._zrId + "-pattern-" + pattern.id);
    dom.setAttribute("x", "0");
    dom.setAttribute("y", "0");
    dom.setAttribute("patternUnits", "userSpaceOnUse");
    this.updateDom(pattern, dom);
    this.addDom(dom);
    return dom;
  };
  PatternManager2.prototype.update = function(pattern) {
    if (!isPattern(pattern)) {
      return;
    }
    var that = this;
    this.doUpdate(pattern, function() {
      var dom = patternDomMap.get(pattern);
      that.updateDom(pattern, dom);
    });
  };
  PatternManager2.prototype.updateDom = function(pattern, patternDom) {
    var svgElement = pattern.svgElement;
    if (svgElement instanceof SVGElement) {
      if (svgElement.parentNode !== patternDom) {
        patternDom.innerHTML = "";
        patternDom.appendChild(svgElement);
        patternDom.setAttribute("width", pattern.svgWidth + "");
        patternDom.setAttribute("height", pattern.svgHeight + "");
      }
    } else {
      var img = void 0;
      var prevImage = patternDom.getElementsByTagName("image");
      if (prevImage.length) {
        if (pattern.image) {
          img = prevImage[0];
        } else {
          patternDom.removeChild(prevImage[0]);
          return;
        }
      } else if (pattern.image) {
        img = this.createElement("image");
      }
      if (img) {
        var imageSrc = void 0;
        var patternImage = pattern.image;
        if (typeof patternImage === "string") {
          imageSrc = patternImage;
        } else if (patternImage instanceof HTMLImageElement) {
          imageSrc = patternImage.src;
        } else if (patternImage instanceof HTMLCanvasElement) {
          imageSrc = patternImage.toDataURL();
        }
        if (imageSrc) {
          img.setAttribute("href", imageSrc);
          img.setAttribute("x", "0");
          img.setAttribute("y", "0");
          var hostEl = {
            dirty: function() {
            }
          };
          var createdImage = createOrUpdateImage(imageSrc, img, hostEl, function(img2) {
            patternDom.setAttribute("width", img2.width + "");
            patternDom.setAttribute("height", img2.height + "");
          });
          if (createdImage && createdImage.width && createdImage.height) {
            patternDom.setAttribute("width", createdImage.width + "");
            patternDom.setAttribute("height", createdImage.height + "");
          }
          patternDom.appendChild(img);
        }
      }
    }
    var x = pattern.x || 0;
    var y = pattern.y || 0;
    var rotation = (pattern.rotation || 0) / Math.PI * 180;
    var scaleX = pattern.scaleX || 1;
    var scaleY = pattern.scaleY || 1;
    var transform = "translate(" + x + ", " + y + ") rotate(" + rotation + ") scale(" + scaleX + ", " + scaleY + ")";
    patternDom.setAttribute("patternTransform", transform);
    patternDomMap.set(pattern, patternDom);
  };
  PatternManager2.prototype.markUsed = function(displayable) {
    if (displayable.style) {
      if (isPattern(displayable.style.fill)) {
        _super.prototype.markDomUsed.call(this, patternDomMap.get(displayable.style.fill));
      }
      if (isPattern(displayable.style.stroke)) {
        _super.prototype.markDomUsed.call(this, patternDomMap.get(displayable.style.stroke));
      }
    }
  };
  return PatternManager2;
}(Definable_default);
var PatternManager_default = PatternManager;

// node_modules/zrender/lib/svg/helper/ClippathManager.js
function generateClipPathsKey(clipPaths) {
  var key = [];
  if (clipPaths) {
    for (var i = 0; i < clipPaths.length; i++) {
      var clipPath = clipPaths[i];
      key.push(clipPath.id);
    }
  }
  return key.join(",");
}
function hasClipPath(displayable) {
  var clipPaths = displayable.__clipPaths;
  return clipPaths && clipPaths.length > 0;
}
var ClippathManager = function(_super) {
  __extends(ClippathManager2, _super);
  function ClippathManager2(zrId, svgRoot) {
    var _this = _super.call(this, zrId, svgRoot, "clipPath", "__clippath_in_use__") || this;
    _this._refGroups = {};
    _this._keyDuplicateCount = {};
    return _this;
  }
  ClippathManager2.prototype.markAllUnused = function() {
    _super.prototype.markAllUnused.call(this);
    for (var key in this._refGroups) {
      this.markDomUnused(this._refGroups[key]);
    }
    this._keyDuplicateCount = {};
  };
  ClippathManager2.prototype._getClipPathGroup = function(displayable, prevDisplayable) {
    if (!hasClipPath(displayable)) {
      return;
    }
    var clipPaths = displayable.__clipPaths;
    var keyDuplicateCount = this._keyDuplicateCount;
    var clipPathKey = generateClipPathsKey(clipPaths);
    if (isClipPathChanged(clipPaths, prevDisplayable && prevDisplayable.__clipPaths)) {
      keyDuplicateCount[clipPathKey] = keyDuplicateCount[clipPathKey] || 0;
      keyDuplicateCount[clipPathKey] && (clipPathKey += "-" + keyDuplicateCount[clipPathKey]);
      keyDuplicateCount[clipPathKey]++;
    }
    return this._refGroups[clipPathKey] || (this._refGroups[clipPathKey] = this.createElement("g"));
  };
  ClippathManager2.prototype.update = function(displayable, prevDisplayable) {
    var clipGroup = this._getClipPathGroup(displayable, prevDisplayable);
    if (clipGroup) {
      this.markDomUsed(clipGroup);
      this.updateDom(clipGroup, displayable.__clipPaths);
    }
    return clipGroup;
  };
  ;
  ClippathManager2.prototype.updateDom = function(parentEl, clipPaths) {
    if (clipPaths && clipPaths.length > 0) {
      var defs = this.getDefs(true);
      var clipPath = clipPaths[0];
      var clipPathEl = void 0;
      var id = void 0;
      if (clipPath._dom) {
        id = clipPath._dom.getAttribute("id");
        clipPathEl = clipPath._dom;
        if (!defs.contains(clipPathEl)) {
          defs.appendChild(clipPathEl);
        }
      } else {
        id = "zr" + this._zrId + "-clip-" + this.nextId;
        ++this.nextId;
        clipPathEl = this.createElement("clipPath");
        clipPathEl.setAttribute("id", id);
        defs.appendChild(clipPathEl);
        clipPath._dom = clipPathEl;
      }
      var svgProxy = this.getSvgProxy(clipPath);
      svgProxy.brush(clipPath);
      var pathEl = this.getSvgElement(clipPath);
      clipPathEl.innerHTML = "";
      clipPathEl.appendChild(pathEl);
      parentEl.setAttribute("clip-path", "url(#" + id + ")");
      if (clipPaths.length > 1) {
        this.updateDom(clipPathEl, clipPaths.slice(1));
      }
    } else {
      if (parentEl) {
        parentEl.setAttribute("clip-path", "none");
      }
    }
  };
  ;
  ClippathManager2.prototype.markUsed = function(displayable) {
    var _this = this;
    if (displayable.__clipPaths) {
      each(displayable.__clipPaths, function(clipPath) {
        if (clipPath._dom) {
          _super.prototype.markDomUsed.call(_this, clipPath._dom);
        }
      });
    }
  };
  ;
  ClippathManager2.prototype.removeUnused = function() {
    _super.prototype.removeUnused.call(this);
    var newRefGroupsMap = {};
    for (var key in this._refGroups) {
      var group = this._refGroups[key];
      if (!this.isDomUnused(group)) {
        newRefGroupsMap[key] = group;
      } else if (group.parentNode) {
        group.parentNode.removeChild(group);
      }
    }
    this._refGroups = newRefGroupsMap;
  };
  return ClippathManager2;
}(Definable_default);
var ClippathManager_default = ClippathManager;

// node_modules/zrender/lib/svg/helper/ShadowManager.js
var ShadowManager = function(_super) {
  __extends(ShadowManager2, _super);
  function ShadowManager2(zrId, svgRoot) {
    var _this = _super.call(this, zrId, svgRoot, ["filter"], "__filter_in_use__", "_shadowDom") || this;
    _this._shadowDomMap = {};
    _this._shadowDomPool = [];
    return _this;
  }
  ShadowManager2.prototype._getFromPool = function() {
    var shadowDom = this._shadowDomPool.pop();
    if (!shadowDom) {
      shadowDom = this.createElement("filter");
      shadowDom.setAttribute("id", "zr" + this._zrId + "-shadow-" + this.nextId++);
      var domChild = this.createElement("feDropShadow");
      shadowDom.appendChild(domChild);
      this.addDom(shadowDom);
    }
    return shadowDom;
  };
  ShadowManager2.prototype.update = function(svgElement, displayable) {
    var style = displayable.style;
    if (hasShadow(style)) {
      var shadowKey = getShadowKey(displayable);
      var shadowDom = displayable._shadowDom = this._shadowDomMap[shadowKey];
      if (!shadowDom) {
        shadowDom = this._getFromPool();
        this._shadowDomMap[shadowKey] = shadowDom;
      }
      this.updateDom(svgElement, displayable, shadowDom);
    } else {
      this.remove(svgElement, displayable);
    }
  };
  ShadowManager2.prototype.remove = function(svgElement, displayable) {
    if (displayable._shadowDom != null) {
      displayable._shadowDom = null;
      svgElement.style.filter = "";
    }
  };
  ShadowManager2.prototype.updateDom = function(svgElement, displayable, shadowDom) {
    var domChild = shadowDom.children[0];
    var style = displayable.style;
    var globalScale = displayable.getGlobalScale();
    var scaleX = globalScale[0];
    var scaleY = globalScale[1];
    if (!scaleX || !scaleY) {
      return;
    }
    var offsetX = style.shadowOffsetX || 0;
    var offsetY = style.shadowOffsetY || 0;
    var blur = style.shadowBlur;
    var color = style.shadowColor;
    domChild.setAttribute("dx", offsetX / scaleX + "");
    domChild.setAttribute("dy", offsetY / scaleY + "");
    domChild.setAttribute("flood-color", color);
    var stdDx = blur / 2 / scaleX;
    var stdDy = blur / 2 / scaleY;
    var stdDeviation = stdDx + " " + stdDy;
    domChild.setAttribute("stdDeviation", stdDeviation);
    shadowDom.setAttribute("x", "-100%");
    shadowDom.setAttribute("y", "-100%");
    shadowDom.setAttribute("width", "300%");
    shadowDom.setAttribute("height", "300%");
    displayable._shadowDom = shadowDom;
    var id = shadowDom.getAttribute("id");
    svgElement.style.filter = "url(#" + id + ")";
  };
  ShadowManager2.prototype.removeUnused = function() {
    var defs = this.getDefs(false);
    if (!defs) {
      return;
    }
    var shadowDomsPool = this._shadowDomPool;
    for (var key in this._shadowDomMap) {
      var dom = this._shadowDomMap[key];
      shadowDomsPool.push(dom);
    }
    this._shadowDomMap = {};
  };
  return ShadowManager2;
}(Definable_default);
var ShadowManager_default = ShadowManager;
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  var style = displayable.style;
  var globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}

// node_modules/zrender/lib/svg/Painter.js
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSvgProxy(el) {
  if (el instanceof Path_default) {
    return svgPath;
  } else if (el instanceof Image_default) {
    return svgImage;
  } else if (el instanceof TSpan_default) {
    return svgText;
  } else {
    return svgPath;
  }
}
function checkParentAvailable(parent, child) {
  return child && parent && child.parentNode !== parent;
}
function insertAfter(parent, child, prevSibling) {
  if (checkParentAvailable(parent, child) && prevSibling) {
    var nextSibling = prevSibling.nextSibling;
    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
  }
}
function prepend(parent, child) {
  if (checkParentAvailable(parent, child)) {
    var firstChild = parent.firstChild;
    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
  }
}
function remove(parent, child) {
  if (child && parent && child.parentNode === parent) {
    parent.removeChild(child);
  }
}
function removeFromMyParent(child) {
  if (child && child.parentNode) {
    child.parentNode.removeChild(child);
  }
}
function getSvgElement(displayable) {
  return displayable.__svgEl;
}
var SVGPainter = function() {
  function SVGPainter2(root, storage, opts, zrId) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport("refreshHover");
    this.pathToImage = createMethodNotSupport("pathToImage");
    this.configLayer = createMethodNotSupport("configLayer");
    this.root = root;
    this.storage = storage;
    this._opts = opts = extend({}, opts || {});
    var svgDom = createElement("svg");
    svgDom.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
    svgDom.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
    svgDom.setAttribute("version", "1.1");
    svgDom.setAttribute("baseProfile", "full");
    svgDom.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
    var bgRoot = createElement("g");
    svgDom.appendChild(bgRoot);
    var svgRoot = createElement("g");
    svgDom.appendChild(svgRoot);
    this._gradientManager = new GradientManager_default(zrId, svgRoot);
    this._patternManager = new PatternManager_default(zrId, svgRoot);
    this._clipPathManager = new ClippathManager_default(zrId, svgRoot);
    this._shadowManager = new ShadowManager_default(zrId, svgRoot);
    var viewport = document.createElement("div");
    viewport.style.cssText = "overflow:hidden;position:relative";
    this._svgDom = svgDom;
    this._svgRoot = svgRoot;
    this._backgroundRoot = bgRoot;
    this._viewport = viewport;
    root.appendChild(viewport);
    viewport.appendChild(svgDom);
    this.resize(opts.width, opts.height);
    this._visibleList = [];
  }
  SVGPainter2.prototype.getType = function() {
    return "svg";
  };
  SVGPainter2.prototype.getViewportRoot = function() {
    return this._viewport;
  };
  SVGPainter2.prototype.getSvgDom = function() {
    return this._svgDom;
  };
  SVGPainter2.prototype.getSvgRoot = function() {
    return this._svgRoot;
  };
  SVGPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  SVGPainter2.prototype.refresh = function() {
    var list = this.storage.getDisplayList(true);
    this._paintList(list);
  };
  SVGPainter2.prototype.setBackgroundColor = function(backgroundColor) {
    if (this._backgroundRoot && this._backgroundNode) {
      this._backgroundRoot.removeChild(this._backgroundNode);
    }
    var bgNode = createElement("rect");
    bgNode.setAttribute("width", this.getWidth());
    bgNode.setAttribute("height", this.getHeight());
    bgNode.setAttribute("x", 0);
    bgNode.setAttribute("y", 0);
    bgNode.setAttribute("id", 0);
    bgNode.style.fill = backgroundColor;
    this._backgroundRoot.appendChild(bgNode);
    this._backgroundNode = bgNode;
  };
  SVGPainter2.prototype.createSVGElement = function(tag) {
    return createElement(tag);
  };
  SVGPainter2.prototype.paintOne = function(el) {
    var svgProxy = getSvgProxy(el);
    svgProxy && svgProxy.brush(el);
    return getSvgElement(el);
  };
  SVGPainter2.prototype._paintList = function(list) {
    var gradientManager = this._gradientManager;
    var patternManager = this._patternManager;
    var clipPathManager = this._clipPathManager;
    var shadowManager = this._shadowManager;
    gradientManager.markAllUnused();
    patternManager.markAllUnused();
    clipPathManager.markAllUnused();
    shadowManager.markAllUnused();
    var svgRoot = this._svgRoot;
    var visibleList = this._visibleList;
    var listLen = list.length;
    var newVisibleList = [];
    for (var i = 0; i < listLen; i++) {
      var displayable = list[i];
      var svgProxy = getSvgProxy(displayable);
      var svgElement = getSvgElement(displayable);
      if (!displayable.invisible) {
        if (displayable.__dirty || !svgElement) {
          svgProxy && svgProxy.brush(displayable);
          svgElement = getSvgElement(displayable);
          if (svgElement && displayable.style) {
            gradientManager.update(displayable.style.fill);
            gradientManager.update(displayable.style.stroke);
            patternManager.update(displayable.style.fill);
            patternManager.update(displayable.style.stroke);
            shadowManager.update(svgElement, displayable);
          }
          displayable.__dirty = 0;
        }
        if (svgElement) {
          newVisibleList.push(displayable);
        }
      }
    }
    var diff2 = arrayDiff(visibleList, newVisibleList);
    var prevSvgElement;
    var topPrevSvgElement;
    for (var i = 0; i < diff2.length; i++) {
      var item = diff2[i];
      if (item.removed) {
        for (var k = 0; k < item.count; k++) {
          var displayable = visibleList[item.indices[k]];
          var svgElement = getSvgElement(displayable);
          hasClipPath(displayable) ? removeFromMyParent(svgElement) : remove(svgRoot, svgElement);
        }
      }
    }
    var prevDisplayable;
    var currentClipGroup;
    for (var i = 0; i < diff2.length; i++) {
      var item = diff2[i];
      if (item.removed) {
        continue;
      }
      for (var k = 0; k < item.count; k++) {
        var displayable = newVisibleList[item.indices[k]];
        var clipGroup = clipPathManager.update(displayable, prevDisplayable);
        if (clipGroup !== currentClipGroup) {
          prevSvgElement = topPrevSvgElement;
          if (clipGroup) {
            prevSvgElement ? insertAfter(svgRoot, clipGroup, prevSvgElement) : prepend(svgRoot, clipGroup);
            topPrevSvgElement = clipGroup;
            prevSvgElement = null;
          }
          currentClipGroup = clipGroup;
        }
        var svgElement = getSvgElement(displayable);
        prevSvgElement ? insertAfter(currentClipGroup || svgRoot, svgElement, prevSvgElement) : prepend(currentClipGroup || svgRoot, svgElement);
        prevSvgElement = svgElement || prevSvgElement;
        if (!currentClipGroup) {
          topPrevSvgElement = prevSvgElement;
        }
        gradientManager.markUsed(displayable);
        gradientManager.addWithoutUpdate(svgElement, displayable);
        patternManager.markUsed(displayable);
        patternManager.addWithoutUpdate(svgElement, displayable);
        clipPathManager.markUsed(displayable);
        prevDisplayable = displayable;
      }
    }
    gradientManager.removeUnused();
    patternManager.removeUnused();
    clipPathManager.removeUnused();
    shadowManager.removeUnused();
    this._visibleList = newVisibleList;
  };
  SVGPainter2.prototype.resize = function(width, height) {
    var viewport = this._viewport;
    viewport.style.display = "none";
    var opts = this._opts;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    width = this._getSize(0);
    height = this._getSize(1);
    viewport.style.display = "";
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      var viewportStyle = viewport.style;
      viewportStyle.width = width + "px";
      viewportStyle.height = height + "px";
      var svgRoot = this._svgDom;
      svgRoot.setAttribute("width", width + "");
      svgRoot.setAttribute("height", height + "");
    }
    if (this._backgroundNode) {
      this._backgroundNode.setAttribute("width", width);
      this._backgroundNode.setAttribute("height", height);
    }
  };
  SVGPainter2.prototype.getWidth = function() {
    return this._width;
  };
  SVGPainter2.prototype.getHeight = function() {
    return this._height;
  };
  SVGPainter2.prototype._getSize = function(whIdx) {
    var opts = this._opts;
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var root = this.root;
    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  };
  SVGPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
  };
  SVGPainter2.prototype.clear = function() {
    var viewportNode = this._viewport;
    if (viewportNode && viewportNode.parentNode) {
      viewportNode.parentNode.removeChild(viewportNode);
    }
  };
  SVGPainter2.prototype.toDataURL = function() {
    this.refresh();
    var svgDom = this._svgDom;
    var outerHTML = svgDom.outerHTML || (svgDom.parentNode && svgDom.parentNode).innerHTML;
    var html = encodeURIComponent(outerHTML.replace(/></g, ">\n\r<"));
    return "data:image/svg+xml;charset=UTF-8," + html;
  };
  return SVGPainter2;
}();
function createMethodNotSupport(method) {
  return function() {
    logError('In SVG mode painter not support method "' + method + '"');
  };
}
var Painter_default = SVGPainter;

// node_modules/echarts/lib/renderer/installSVGRenderer.js
function install(registers) {
  registers.registerPainter("svg", Painter_default);
}

// node_modules/zrender/lib/canvas/Layer.js
function returnFalse() {
  return false;
}
function createDom(id, painter, dpr) {
  var newDom = createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr;
  newDom.height = height * dpr;
  return newDom;
}
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id, painter, dpr) {
    var _this = _super.call(this) || this;
    _this.motionBlur = false;
    _this.lastFrameAlpha = 0.7;
    _this.dpr = 1;
    _this.virtual = false;
    _this.config = {};
    _this.incremental = false;
    _this.zlevel = 0;
    _this.maxRepaintRectCount = 5;
    _this.__dirty = true;
    _this.__firstTimePaint = true;
    _this.__used = false;
    _this.__drawIndex = 0;
    _this.__startIndex = 0;
    _this.__endIndex = 0;
    _this.__prevStartIndex = null;
    _this.__prevEndIndex = null;
    var dom;
    dpr = dpr || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr);
    } else if (isObject(id)) {
      dom = id;
      id = dom.id;
    }
    _this.id = id;
    _this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      dom.onselectstart = returnFalse;
      domStyle.webkitUserSelect = "none";
      domStyle.userSelect = "none";
      domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
      domStyle["-webkit-touch-callout"] = "none";
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    _this.domBack = null;
    _this.ctxBack = null;
    _this.painter = painter;
    _this.config = null;
    _this.dpr = dpr;
    return _this;
  }
  Layer2.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  };
  Layer2.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  };
  Layer2.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  };
  Layer2.prototype.setUnpainted = function() {
    this.__firstTimePaint = true;
  };
  Layer2.prototype.createBackBuffer = function() {
    var dpr = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr !== 1) {
      this.ctxBack.scale(dpr, dpr);
    }
  };
  Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    var mergedRepaintRects = [];
    var maxRepaintRectCount = this.maxRepaintRectCount;
    var full = false;
    var pendingRect = new BoundingRect_default(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        var boundingRect = new BoundingRect_default(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        var isMerged = false;
        var minDeltaArea = Infinity;
        var bestRectToMergeIdx = 0;
        for (var i2 = 0; i2 < mergedRepaintRects.length; ++i2) {
          var mergedRect = mergedRepaintRects[i2];
          if (mergedRect.intersect(rect)) {
            var pendingRect_1 = new BoundingRect_default(0, 0, 0, 0);
            pendingRect_1.copy(mergedRect);
            pendingRect_1.union(rect);
            mergedRepaintRects[i2] = pendingRect_1;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            var aArea = rect.width * rect.height;
            var bArea = mergedRect.width * mergedRect.height;
            var pendingArea = pendingRect.width * pendingRect.height;
            var deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i2;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          var boundingRect = new BoundingRect_default(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (var i = this.__startIndex; i < this.__endIndex; ++i) {
      var el = displayList[i];
      if (el) {
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        var prevRect = el.__isRendered && (el.__dirty & REDARAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        var curRect = shouldPaint && (el.__dirty & REDARAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
      var el = prevList[i];
      var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        var prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    var hasIntersections;
    do {
      hasIntersections = false;
      for (var i = 0; i < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i].isZero()) {
          mergedRepaintRects.splice(i, 1);
          continue;
        }
        for (var j = i + 1; j < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
            hasIntersections = true;
            mergedRepaintRects[i].union(mergedRepaintRects[j]);
            mergedRepaintRects.splice(j, 1);
          } else {
            j++;
          }
        }
        i++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  };
  Layer2.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  };
  Layer2.prototype.resize = function(width, height) {
    var dpr = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr;
    dom.height = height * dpr;
    if (domBack) {
      domBack.width = width * dpr;
      domBack.height = height * dpr;
      if (dpr !== 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    }
  };
  Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr = this.dpr;
    var self = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
    }
    var domBack = this.domBack;
    function doClear(x, y, width2, height2) {
      ctx.clearRect(x, y, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        var clearColorGradientOrPattern = void 0;
        if (isGradientObject(clearColor)) {
          clearColorGradientOrPattern = clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } else if (isImagePatternObject(clearColor)) {
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty: function() {
              self.setUnpainted();
              self.__painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x, y, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x, y, width2, height2);
        ctx.restore();
      }
    }
    ;
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each(repaintRects, function(rect) {
        doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
      });
    }
  };
  return Layer2;
}(Eventful_default);
var Layer_default = Layer;

// node_modules/zrender/lib/canvas/Painter.js
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function parseInt102(val) {
  return parseInt(val, 10);
}
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = function() {
  function CanvasPainter2(root, storage, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    var rootStyle = root.style;
    if (rootStyle) {
      rootStyle.webkitTapHighlightColor = "transparent";
      rootStyle.webkitUserSelect = "none";
      rootStyle.userSelect = "none";
      rootStyle["-webkit-touch-callout"] = "none";
      root.innerHTML = "";
    }
    this.storage = storage;
    var zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    var layers = this._layers;
    if (!singleCanvas) {
      this._width = this._getSize(0);
      this._height = this._getSize(1);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      var rootCanvas = root;
      var width = rootCanvas.width;
      var height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      var mainLayer = new Layer_default(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
  }
  CanvasPainter2.prototype.getType = function() {
    return "canvas";
  };
  CanvasPainter2.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  };
  CanvasPainter2.prototype.getViewportRoot = function() {
    return this._domRoot;
  };
  CanvasPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  CanvasPainter2.prototype.refresh = function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var prevList = this._prevDisplayList;
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  };
  CanvasPainter2.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(false));
  };
  CanvasPainter2.prototype._paintHoverList = function(list) {
    var len = list.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len) {
      return;
    }
    var scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    var ctx;
    for (var i = 0; i < len; i++) {
      var el = list[i];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush(ctx, el, scope, i === len - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  };
  CanvasPainter2.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  };
  CanvasPainter2.prototype.paintOne = function(ctx, el) {
    brushSingle(ctx, el);
  };
  CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var _a = this._doPaintList(list, prevList, paintAll), finished = _a.finished, needsRefreshHover = _a.needsRefreshHover;
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      var self_1 = this;
      requestAnimationFrame_default(function() {
        self_1._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer(function(layer) {
        layer.afterBrush && layer.afterBrush();
      });
    }
  };
  CanvasPainter2.prototype._compositeManually = function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  };
  CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
    var _this = this;
    var layerList = [];
    var useDirtyRect = this._opts.useDirtyRect;
    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    var finished = true;
    var needsRefreshHover = false;
    var _loop_1 = function(k2) {
      var layer2 = layerList[k2];
      var ctx = layer2.ctx;
      var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
      var start = paintAll ? layer2.__startIndex : layer2.__drawIndex;
      var useTimer = !paintAll && layer2.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
      if (layer2.__startIndex === layer2.__endIndex) {
        layer2.clear(false, clearColor, repaintRects);
      } else if (start === layer2.__startIndex) {
        var firstEl = list[start];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer2.clear(false, clearColor, repaintRects);
        }
      }
      if (start === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start = layer2.__startIndex;
      }
      var i;
      var repaint = function(repaintRect) {
        var scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: _this._width,
          viewHeight: _this._height
        };
        for (i = start; i < layer2.__endIndex; i++) {
          var el = list[i];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i === layer2.__endIndex - 1);
          if (useTimer) {
            var dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i = layer2.__endIndex;
        } else {
          var dpr = this_1.dpr;
          for (var r = 0; r < repaintRects.length; ++r) {
            var rect = repaintRects[r];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer2.__drawIndex = i;
      if (layer2.__drawIndex < layer2.__endIndex) {
        finished = false;
      }
    };
    var this_1 = this;
    for (var k = 0; k < layerList.length; k++) {
      _loop_1(k);
    }
    if (env_default.wxa) {
      each(this._layers, function(layer2) {
        if (layer2 && layer2.ctx && layer2.ctx.draw) {
          layer2.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  };
  CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    var ctx = currentLayer.ctx;
    if (useDirtyRect) {
      var paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush(ctx, el, scope, isLast);
    }
  };
  CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer_default("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  };
  CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var domRoot = this._domRoot;
    var prevLayer = null;
    var i = -1;
    if (layersMap[zlevel]) {
      logError("ZLevel " + zlevel + " has been used already");
      return;
    }
    if (!isLayerValid(layer)) {
      logError("Layer of zlevel " + zlevel + " is not valid");
      return;
    }
    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.__painter = this;
  };
  CanvasPainter2.prototype.eachLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  };
  CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  };
  CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  };
  CanvasPainter2.prototype.getLayers = function() {
    return this._layers;
  };
  CanvasPainter2.prototype._updateLayerStatus = function(list) {
    this.eachBuiltinLayer(function(layer2, z) {
      layer2.__dirty = layer2.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i_1 = 1; i_1 < list.length; i_1++) {
        var el = list[i_1];
        if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    var i;
    for (i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer = void 0;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }
        layer.__startIndex = i;
        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer;
      }
      if (el.__dirty & REDARAW_BIT && !el.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer2, z) {
      if (!layer2.__used && layer2.getElementCount() > 0) {
        layer2.__dirty = true;
        layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
      }
      if (layer2.__dirty && layer2.__drawIndex < 0) {
        layer2.__drawIndex = layer2.__startIndex;
      }
    });
  };
  CanvasPainter2.prototype.clear = function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  };
  CanvasPainter2.prototype._clearLayer = function(layer) {
    layer.clear();
  };
  CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor) {
    this._backgroundColor = backgroundColor;
    each(this._layers, function(layer) {
      layer.setUnpainted();
    });
  };
  CanvasPainter2.prototype.configLayer = function(zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge(layerConfig[zlevel], config, true);
      }
      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  };
  CanvasPainter2.prototype.delLayer = function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf(zlevelList, zlevel), 1);
  };
  CanvasPainter2.prototype.resize = function(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  };
  CanvasPainter2.prototype.clearLayer = function(zlevel) {
    var layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  };
  CanvasPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  };
  CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    var ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width_1 = imageLayer.dom.width;
      var height_1 = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      var scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var displayList = this.storage.getDisplayList(true);
      for (var i = 0, len = displayList.length; i < len; i++) {
        var el = displayList[i];
        brush(ctx, el, scope, i === len - 1);
      }
    }
    return imageLayer.dom;
  };
  CanvasPainter2.prototype.getWidth = function() {
    return this._width;
  };
  CanvasPainter2.prototype.getHeight = function() {
    return this._height;
  };
  CanvasPainter2.prototype._getSize = function(whIdx) {
    var opts = this._opts;
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var root = this.root;
    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt102(stl[wh]) || parseInt102(root.style[wh])) - (parseInt102(stl[plt]) || 0) - (parseInt102(stl[prb]) || 0) | 0;
  };
  CanvasPainter2.prototype.pathToImage = function(path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur * dpr;
    var shadowOffsetX = style.shadowOffsetX * dpr;
    var shadowOffsetY = style.shadowOffsetY * dpr;
    var lineWidth = path.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      x: path.x,
      y: path.y,
      scaleX: path.scaleX,
      scaleY: path.scaleY,
      rotation: path.rotation,
      originX: path.originX,
      originY: path.originY
    };
    path.x = leftMargin - rect.x;
    path.y = topMargin - rect.y;
    path.rotation = 0;
    path.scaleX = 1;
    path.scaleY = 1;
    path.updateTransform();
    if (path) {
      brush(ctx, path, {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      }, true);
    }
    var imgShape = new Image_default({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });
    extend(path, pathTransform);
    return imgShape;
  };
  return CanvasPainter2;
}();
var Painter_default2 = CanvasPainter;

// node_modules/echarts/lib/renderer/installCanvasRenderer.js
function install2(registers) {
  registers.registerPainter("canvas", Painter_default2);
}
export {
  install2 as CanvasRenderer,
  install as SVGRenderer
};
//# sourceMappingURL=echarts_renderers.js.map
